aash
====

simple test shell implementing a POSIXish sh as an exercise.

* hand-written lexer
* parser generated by (slightly modified) lemon
* supported syntax:
  - and (a && b)
  - or (a || b)
  - not (!a)
  - quoting ("foo bar", 'baz zblerx', a"x$(foo $(bar))x"'foo')
  - pipes (a | b)
  - redirections (a > b; a 2>&1; a < b; a >> b)
  - subshells ( (a;b) )
  - background process (a &)
  - some builtins (wait, bg, fg)
  - variable assignement and reference (var=foo ; echo "$var" ${var} '$var' )
  - subshell expansion $(foo $(bar) )
  - for loops ( for i in $(seq 4); do echo $i; done )
  - if/then/elif/else
  - functions ( function func() { echo foo; } ; func )
  - some specials vars ($0 $1 $2 $# $$)

* interative mode
  - read multi-line commands (PS1/PS2 (not redefinable))
  - job control with signals and process groups (ctrl-c, ctrl-z, fg, bg)

* unsupported stuff so far:
  - missing some compounded commands (while,until,case,...)
  - missing some builtins (shift, read, getopts...)
  - var expansion parameters ${var:-x} ...
  - no glob expansions ( *.c *.[ch] ~/foo )
  - arithmetic expression $(( 42*10+foo ))

build
=====

aash should only depend on a c11 compiler and the system libc (only tested with gcc and glibc)

    $ make

testing
=======

you can run the test suite to check aash works or to see its supported features.
the test suite requires python3.

    $ python3 test.py -v

usage
=====

    $ ./aash --debug -c '( echo aa ; echo ab ; echo bb ) | grep a | grep b > file; echo "result=$(cat file)"'
    === LEXING ===
    TOK: LPAREN (
    TOK: WORD <echo>
    TOK: WORD <aa>
    TOK: SEMICOL ;
    TOK: WORD <echo>
    TOK: WORD <ab>
    TOK: SEMICOL ;
    TOK: WORD <echo>
    TOK: WORD <bb>
    TOK: RPAREN )
    TOK: PIPE
    TOK: WORD <grep>
    TOK: WORD <a>
    TOK: PIPE
    TOK: WORD <grep>
    TOK: WORD <b>
    TOK: REDIR >
    TOK: WORD <file>
    TOK: SEMICOL ;
    TOK: WORD <echo>
    TOK: WORD <"result=$(cat file)">
    TOK: NEWLINE
    === PARSING ===
    PROG {
      PROG {
        PIPE  {
          SUBSHELL  {
            PROG {
              CMD <echo> <aa> 
              CMD <echo> <ab> 
              CMD <echo> <bb> 
            }
          }
          CMD <grep> <a> 
          CMD <grep> <b> REDIR stdout=fn<file> 
        }
        CMD <echo> <"result=$(cat file)"> 
      }
    }
    === RUNNING ===
    result=ab
    RESULT = 0 (exit code=0)
