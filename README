aash
====

simple test shell implementing a POSIXish sh as an exercise.

* hand-written lexer
* parser generated by (slightly modified) lemon
* supported syntax:
  - and (a && b)
  - or (a || b)
  - not (!a)
  - basic quoting ("foo bar", 'baz zblerx')
  - pipes (a | b)
  - redirections (a > b; a 2>&1; a < b; a >> b)
  - subshells ( (a;b) )
  - background process (a &)
  - some builtins (wait, bg, fg)
  - variable assignement and reference (var=foo ; echo "$var" ${var} '$var' )
  - subshell expansion $(foo $(bar) )
  - for loops ( for i in $(seq 4); do echo $i; done )
  - if/then/elif/else
  - functions ( function func() { echo foo; } ; func )
  - some specials vars ($0 $1 $2 $# $$)

* interative mode
  - read multi-line commands (PS1/PS2)
  - job control with signals and process groups (ctrl-c, ctrl-z, fg, bg)

* unsupported stuff so far:
  - not all compounded commands (while,until,case,...)
  - handle bg jobs and redir in more expressions

build
=====

    $ make

usage
=====

    # sample script
    $ echo '( echo aa && echo ab && echo bb ) | grep a | grep b > file ; cat file
            ( sleep 5 ; echo done ) &
            echo wait
            wait
            echo exiting
    ' > test.sh
    # run it
    $ ./aash --debug < test.sh
    === LEXING ===
    TOK: NEWLINE
    TOK: NEWLINE
    TOK: LPAREN (
    TOK: WORD <echo>
    TOK: WORD <aa>
    TOK: AND
    TOK: WORD <echo>
    TOK: WORD <ab>
    TOK: AND
    TOK: WORD <echo>
    TOK: WORD <bb>
    TOK: RPAREN )
    TOK: PIPE
    TOK: WORD <grep>
    TOK: WORD <a>
    TOK: PIPE
    TOK: WORD <grep>
    TOK: WORD <b>
    TOK: REDIR >
    TOK: WORD <file>
    TOK: SEMICOL ;
    TOK: WORD <cat>
    TOK: WORD <file>
    TOK: NEWLINE
    TOK: LPAREN (
    TOK: WORD <sleep>
    TOK: WORD <5>
    TOK: SEMICOL ;
    TOK: WORD <echo>
    TOK: WORD <done>
    TOK: RPAREN )
    TOK: BG &
    TOK: NEWLINE
    TOK: WORD <echo>
    TOK: WORD <wait>
    TOK: NEWLINE
    TOK: WORD <wait>
    TOK: NEWLINE
    TOK: WORD <echo>
    TOK: WORD <exiting>
    TOK: NEWLINE
    TOK: NONE
    === PARSING ===
    PROG {
      PROG {
        PIPE {
          left {
            PIPE {
              left {
                SUBSHELL REDIR  {
                  PROG {
                    AND {
                      left {
                        AND {
                          left {
                            CMD <echo> <aa> REDIR 
                          }
                          right {
                            CMD <echo> <ab> REDIR 
                          }
                        }
                      }
                      right {
                        CMD <echo> <bb> REDIR 
                      }
                    }
                  }
                }
              }
              right {
                CMD <grep> <a> REDIR 
              }
            }
          }
          right {
            CMD <grep> <b> REDIR stdout=fn<file> 
          }
        }
        CMD <cat> <file> REDIR 
      }
      PROG {
        (in bg)     SUBSHELL REDIR  {
          PROG {
            CMD <sleep> <5> REDIR 
            CMD <echo> <done> REDIR 
          }
        }
      }
      PROG {
        CMD <echo> <wait> REDIR 
      }
      PROG {
        CMD <wait> REDIR 
      }
      PROG {
        CMD <echo> <exiting> REDIR 
      }
    }
    === RUNNING ===
    ab
    wait
    done
    exiting
    RESULT = 0 (exit code=0)

